#!/opt/conda/bin/python

"""
Plot script for Excel files generated by Oracle Crystal Ball.

This program can be fed the name of a Crystal Ball forecast, as
well as a number of Excel workbooks, as command-line arguments.
It will then generate plots of sensitivity analysis data stored
in those workbooks. Note that this requires you to turn on
sensitivity analysis in Crystal Ball before simulation.

Usage:
  ./cbsens.py FORECAST FILE1 [FILE2 [...]]

Example:
  If you have two files `A.xlsx` and `B.xlsx` in the same directory
  as the script, and wish to plot their forecasts for "Result", run:
    ./cbsens.py "Result" "A.xlsx" "B.xlsx"
  The surrounding double quotes are in this case superfluous, but are
  required if the provided forecast name or filenames include spaces.
"""

import sys
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path

# Initialize plot style.
sns.set(rc={"figure.figsize": (4, 3)})
sns.set_style("ticks")
sns.set_palette("Set1")
sns.set_context("paper")

# Print an error and quit if no Excel workbooks were specified.
if len(sys.argv) < 3:
    print(f'Usage: {sys.argv[0]} "Forecast name" /path/to/workbook.xlsx [···]')
    print(f"\nSee the source code comments if you require more documentation.")
    sys.exit(1)

# Which forecast variable to generate histograms for. This has to
# correspond to what the Crystal Ball forecast is named in Excel.
forecast = sys.argv[1]

# Read what workbooks to process from command-line arguments.
books = sys.argv[2:]

# Extract data from the provided workbooks:
for book in books:
    # Status information
    print(f':: Processing "{book}"...')

    # Import all data from Excel workbook.
    try:
        sheets = pd.read_excel(book, sheet_name=None, header=None).values()
    except FileNotFoundError:
        print(f'Error: "{book}" is not a valid workbook.')
        sys.exit(1)

    # Determine where the relevant sensitivity data starts.
    try:
        row_min = [np.where(sheet == "Sensitivity Data")[0][-1] + 2 for sheet in sheets]
        row_max = [np.where(sheet == "Trial values")[0][-1] - 2 for sheet in sheets]
        col_lab = [np.where(sheet == "Sensitivity Data")[1][-1] for sheet in sheets]
        col_dat = [np.where(sheet == forecast)[1][-1] for sheet in sheets]
    except IndexError:
        print(f'Warning: Not all sheets in "{book}" have requested sensitivity data.')
        print("Skipping this workbook...")
        continue

    # Extract the labels from the first sheet.
    # (A hack since `sheet` is not indexable.)
    for sheet in sheets:
        labels = [*sheet[col_lab[0]][row_min[0] : row_max[0]]]
        break

    # Average sensitivity data from all sheets.
    data = np.mean(
        np.array(
            [
                sheet[col_dat[i]][row_min[i] : row_max[i]]
                for i, sheet in enumerate(sheets)
            ]
        ),
        axis=0,
    )

    # Write the sensitivity data to output file.
    results = {k: v for k, v in zip(labels, data)}
    output = Path(book).with_suffix(".sens.dat")
    print(f'   Writing stats to "{output}".')
    with open(output, "w") as f:
        f.write(f"# Crystal Ball sensitivity data\n")
        f.write(f"# Workbook: {book}\n")
        f.write(f"# Forecast: {forecast}\n")
        for k, v in results.items():
            f.write("%-64s %.6g\n" % (k, v))

    # Plot the results as a bar chart.
    ax = sns.barplot(100 * data, labels)
    ax.axvline(x=0.0, ls="solid", lw=1, c="k")
    plt.xlim([-1, 1])
    plt.xticks([-100, -50, 0, 50, 100])
    plt.xlabel("Sensitivity [%]")
    plt.title(Path(book).stem)
    plt.tight_layout()
    plt.show()
